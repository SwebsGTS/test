'use strict';

var _setImmediate2 = require('babel-runtime/core-js/set-immediate');

var _setImmediate3 = _interopRequireDefault(_setImmediate2);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// The event loop.
//
// Each browser has an event loop, which processes asynchronous events like
// loading pages and resources, XHR, timeouts and intervals, etc. These are
// procesed in order.
//
// The purpose of the event loop is two fold:
// - To get events processed in the right order for the active window (and only
//   the active window)
// - And to allow the code to wait until all events have been processed
//   (browser.wait, .visit, .pressButton, etc)
//
// The event loop has one interesting method: `wait`.
//
// Each window maintains its own event queue. Its interesting methods are
// `enqueue`, `http`, `dispatch` and the timeout/interval methods.


const assert = require('assert');
const { EventEmitter } = require('events');
const { idlUtils } = require('./dom/impl');

// Wrapper for a timeout (setTimeout)
class Timeout {

  // eventQueue - Reference to the event queue
  // fn         - When timer fires, evaluate this function
  // delay      - How long to wait
  // remove     - Call this to discard timer
  //
  // Instance variables add:
  // handle  - Node.js timeout handle
  // next    - When is this timer firing next
  constructor(eventQueue, fn, delay, remove) {
    this.eventQueue = eventQueue;
    this.fn = fn;
    this.delay = Math.max(delay || 0, 0);
    this.remove = remove;

    this.handle = global.setTimeout(this.fire.bind(this), this.delay);
    this.next = Date.now() + this.delay;
  }

  fire() {
    // In response to Node firing setTimeout, but only allowed to process this
    // event during a wait()
    this.eventQueue.enqueue(() => {
      const { eventLoop } = this.eventQueue;
      eventLoop.emit('setTimeout', this.fn, this.delay);
      try {
        this.eventQueue.window._evaluate(this.fn);
      } catch (error) {
        eventLoop.emit('error', error);
      }
    });
    this.remove();
  }

  // clearTimeout
  stop() {
    global.clearTimeout(this.handle);
    this.remove();
  }

}

// Wrapper for an interval (setInterval)
class Interval {

  // eventQueue - Reference to the event queue
  // fn        - When timer fires, evaluate this function
  // interval  - Interval between firing
  // remove    - Call this to discard timer
  //
  // Instance variables add:
  // handle  - Node.js interval handle
  // next    - When is this timer firing next
  constructor(eventQueue, fn, interval, remove) {
    this.eventQueue = eventQueue;
    this.fn = fn;
    this.interval = Math.max(interval || 0, 0);
    this.remove = remove;
    this.fireInProgress = false;
    this.handle = global.setInterval(this.fire.bind(this), this.interval);
    this.next = Date.now() + this.interval;
  }

  fire() {
    // In response to Node firing setInterval, but only allowed to process this
    // event during a wait()
    this.next = Date.now() + this.interval;

    // setInterval events not allowed to overlap, don't queue two at once
    if (this.fireInProgress) return;
    this.fireInProgress = true;
    this.eventQueue.enqueue(() => {
      this.fireInProgress = false;

      const { eventLoop } = this.eventQueue;
      eventLoop.emit('setInterval', this.fn, this.interval);
      try {
        this.eventQueue.window._evaluate(this.fn);
      } catch (error) {
        eventLoop.emit('error', error);
      }
    });
  }

  // clearTimeout
  stop() {
    global.clearInterval(this.handle);
    this.remove();
  }

}

// Each window has an event queue that holds all pending events.  Various
// browser features push new functions into the queue (e.g. process XHR
// response, setTimeout fires).  The event loop is responsible to pop these
// events from the queue and run them, but only during browser.wait().
//
// In addition, the event queue keeps track of all outstanding timers
// (setTimeout/setInterval) so it can return consecutive handles and clean them
// up during window.destroy().
//
// In addition, we keep track of when the browser is expecting an event to
// arrive in the queue (e.g. sent XHR request, expecting an event to process the
// response soon enough).  The event loop uses that to determine if it's worth
// waiting.
class EventQueue {

  // Instance variables:
  // browser          - Reference to the browser
  // eventLoop        - Reference to the browser's event loop
  // queue            - FIFO queue of functions to call
  // expecting        - These are holding back the event loop
  // timers           - Sparse array of timers (index is the timer handle)
  // eventSources     - Additional sources for events (SSE, WS, etc)
  // nextTimerHandle  - Value of next timer handler
  constructor(window) {
    this.window = window;
    this.browser = window.browser;
    this.eventLoop = this.browser._eventLoop;
    this.queue = [];
    this.expecting = 0;
    this.timers = [];
    this.eventSources = [];
    this.nextTimerHandle = 1;
  }

  // Cleanup when we dispose of the window
  destroy() {
    if (!this.queue) return;
    this.queue = null;

    for (let timer of this.timers) if (timer) timer.stop();
    this.timers = null;

    for (let eventSource of this.eventSources)
    //if (eventSource)
    eventSource.close();
    this.eventSources = null;
  }

  // -- Events --

  // Any events expected in the future?
  get expected() {
    return !!(this.expecting || (0, _from2.default)(this.window.frames).filter(frame => frame._eventQueue.expected).length);
  }

  // Add a function to the event queue, to be executed in order.
  enqueue(fn) {
    assert(this.queue, 'This browser has been destroyed');
    assert(typeof fn === 'function', 'eventLoop.enqueue called without a function');

    if (fn) {
      this.queue.push(fn);
      this.eventLoop.run();
    }
  }

  // Wait for completion.  Returns a completion function, event loop will remain
  // active until the completion 